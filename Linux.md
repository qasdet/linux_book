
*   **Ядро (Kernel)** — это мэр и центральная диспетчерская города. Оно распределяет ресурсы (электричество, воду, дороги — т.е. процессорное время, память, дисковый ввод-вывод).
*   **Процессы** — это все **жители и предприятия** города, которые прямо сейчас что-то делают.
*   **Службы (Демоны)** — это **критическая инфраструктура** города: электростанция, водоканал, пожарная служба, больница. Они работают круглосуточно, часто в фоновом режиме, чтобы город был жизнеспособен.

Теперь разберем подробнее по пунктам.

---

### 1. Процессы: Жители и Предприятия

**Процесс** — это экземпляр выполняющейся программы. Каждый раз, когда вы запускаете команду (например, `ls`, `firefox`), ядро создает новый процесс.

**Ключевые атрибуты процесса:**
*   **PID (Process ID):** Уникальный идентификационный номер процесса. Как паспорт или номер налогоплательщика.
*   **PPID (Parent Process ID):** PID процесса-родителя, который породил данный процесс. В Linux почти все процессы являются потомками первого процесса `init` или `systemd` (PID 1).
*   **Статус:** Процесс не всегда активен. Он может быть:
    *   **Running (R):** Выполняется на CPU прямо сейчас.
    *   **Sleeping (S):** Ждет какого-то события (например, пользовательского ввода, данных из сети).
    *   **Zombie (Z):** Процесс завершился, но его запись еще есть в таблице процессов (ожидает, что родитель "спросит" о его статусе завершения). Это нормально, но если зомби не убираются — это проблема.
*   **Ресурсы:** У каждого процесса есть свое виртуальное адресное пространство (память), открытые файлы, переменные окружения.

**Как посмотреть процессы?**
*   `ps aux` — моментальный снимок процессов.
*   `top` или `htop` — динамическое, интерактивное представление (как "панель управления" мэра в реальном времени).

**Жизненный цикл:** Процесс создается через системный вызов `fork()` (создает копию родителя) и затем `exec()` (загружает в эту копию новую программу). Завершается через `exit()`.

---

### 2. Службы (Демоны): Критическая Инфраструктура

**Служба (Демон)** — это особый тип процесса. Это фоновый процесс, который работает независимо от пользовательского сеанса и управляет системными ресурсами, предоставляет услуги другим процессам (демонам и приложениям).

**Характеристики демонов:**
*   **Независимость от терминала:** Они intentionally отсоединяются от управляющего терминала (tty), чтобы их нельзя было случайно завершить по сигналу `SIGHUP` (например, при закрытии SSH-сессии).
*   **Долгоживущие:** Запускаются при загрузке системы и работают до ее выключения.
*   **Часто работают от имени root:** Имеют привилегии для управления системными ресурсами.

**Примеры служб:**
*   `sshd` — предоставляет услуги по удаленному доступу (SSH).
*   `nginx` / `apache2` — веб-сервер.
*   `cron` — выполняет задачи по расписанию.
*   `systemd-logind` — управляет пользовательскими сеансами.

---

### 3. Менеджер служб: Управляющая Компания

Чтобы инфраструктура (демоны) работала слаженно, нужна "управляющая компания". В современных дистрибутивах Linux эту роль выполняет **systemd**.

**Systemd** — это менеджер служб и init-система (первый процесс с PID 1, который запускает всех остальных). Это архитектурный центр всего города.

**Как systemd управляет службами?**
Вместо скриптов в `/etc/init.d/` (как было в SysVinit), systemd использует **unit-файлы** (файлы конфигурации с расширением `.service`, `.socket`, `.timer` и др.), которые обычно лежат в `/etc/systemd/system/` и `/usr/lib/systemd/system/`.

**Основные команды управления:**
*   `systemctl start <service_name>` — запустить службу.
*   `systemctl stop <service_name>` — остановить службу.
*   `systemctl restart <service_name>` — перезапустить.
*   `systemctl status <service_name>` — показать статус, логи последних событий. **Это ваша главная команда для диагностики!**
*   `systemctl enable <service_name>` — включить автозагрузку службы при старте системы.
*   `systemctl disable <service_name>` — выключить автозагрузку.
*   `systemctl daemon-reload` — применить изменения в unit-файлах (после их редактирования).

**Преимущества systemd:**
*   **Параллельный запуск:** Запускает службы параллельно, где это возможно, что ускоряет загрузку системы.
*   **Зависимости:** Четко описывает зависимости между службами (например, "сетевой сервис должен запуститься до веб-сервера").
*   **Мощное логирование:** Встроенная служба `journald` собирает логи всех демонов, управляемых systemd. Просмотр через `journalctl -u <service_name>`.

---

### 4. Взаимодействие и коммуникация: Дороги и Трубы

Процессы и службы не живут в вакууме. Они постоянно общаются.

*   **Сигналы (Signals):** Простейший способ управления. Это асинхронные уведомления. Например:
    *   `SIGTERM` (15) — вежливая просьба завершиться.
    *   `SIGKILL` (9) — немедленное убийство процесса (нельзя перехватить или проигнорировать).
    *   `SIGHUP` (1) — часто сигнализирует демону "перечитай свои конфиги".
    *   Команда `kill -9 <PID>` отправляет сигнал SIGKILL.
*   **Сокеты (Sockets):** Межпроцессное взаимодействие (IPC). Служба `sshd` "слушает" TCP-сокет на 22-м порту, ожидая входящих подключений.
*   **Каналы (Pipes |):** Команда в shell вроде `ps aux | grep ssh` создает канал, куда процесс `ps` пишет данные, а процесс `grep` из него читает.

### Архитектурная сводка (Резюме)

1.  **Загрузка:** Ядро загружается и запускает `systemd` (PID 1).
2.  **Инициализация:** `Systemd` анализирует свои unit-файлы, строит граф зависимостей и **параллельно запускает целевые службы** (например, `multi-user.target`), которые, в свою очередь, запускают демонов (`sshd`, `nginx` и т.д.).
3.  **Рабочий режим:** Демоны работают в фоне, ожидая запросов (на портах, через сокеты, по таймеру).
4.  **Пользовательское взаимодействие:** Пользователь входит в систему (через `sshd` или `getty`). Запускается его оболочка (shell, например, `bash`). Каждая команда в оболочке порождает новый **процесс**.
5.  **Мониторинг:** Администратор использует `systemctl status` и `journalctl` для наблюдения за здоровьем служб и `top`, `ps` для наблюдения за процессами.
6.  **Завершение:** При shutdown `systemd` корректно останавливает все службы (отправляя им SIGTERM, давая время на завершение работы), а затем уничтожает упрямых (SIGKILL).

Понимание этой иерархии и взаимодействия — ключ к эффективному администрированию, диагностике проблем и проектированию развертывания приложений в Linux-среде.